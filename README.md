一款结合了算术逻辑与空间博弈的策略棋盘游戏
核心玩法

棋盘结构：一个 6x6 的格网，每个格子里随机分布着数字（这些数字是 1~9 之间两个数相乘的所有可能结果）
因数轨道：底部有 1~9 的数字刻度，以及两个移动滑块（A 和 B）。
占领格子：玩家通过移动其中一个滑块，使两个滑块所指向的数字之积对应棋盘上的某个格子，从而占领该格子

详细规则

1. 开局（第 1 步）：
玩家 1 放置第一个滑块 A。此时不占领任何棋盘格子。

2. 建立连接（第 2 步）：
玩家 2 放置第二个滑块 B。此时产生第一个乘积，玩家 2 占领对应的格子。
3. 常规回合（第 3 步起）：
玩家轮流行动。每次只能移动其中一个滑块（A 或 B）到另一个数字上。
限制：必须移动滑块，不能停留在原位。
冲突：如果移动后计算出的乘积格子已被占领（无论是被谁占领），则该移动无效，必须选择其他数字
4. 死局判定：
如果当前玩家移动 A 或 B 到任何位置产生的乘积都已被占领，则该玩家无路可走，被迫投降
5. 获胜条件

连线成珠：率先在棋盘上形成连续四/三个棋子（横向、纵向、或对角线方向）的一方立即获胜


项目开发文档

1. 项目概述

游戏名称：New Product Game
核心玩法：玩家通过移动底部的两个滑块（因数）来占领棋盘上对应的乘积格子。率先在 6x6 棋盘上形成“四/三子连线”的一方获胜
技术栈：React (Vite), CSS3 (Flexbox/Grid), JavaScript (ES6+)

2. 核心文件结构

`src/App.jsx`: 状态管理中心。控制游戏流程（回合切换、胜负判定）、多语言解析逻辑以及与 AI 逻辑的对接
`src/App.css`: 响应式样式表。包含棋盘的 Grid 布局、因数轨道的绝对定位、获胜高亮动画以及移动端适配逻辑
`src/ai.js`: 独立的 AI 策略文件。目前实现为随机合法落子，预留了 `getAIMove` 接口用于后续接入其他算法
`src/i18n.js`: 国际化配置包。采用 KeyValue 模式存储文本，支持动态参数填充（如：`{{player}}`）

3. 已实现的重点功能

动态棋盘生成：每次开局随机，确保每局体验不同
智能合法性检查：禁止占领已被他人占据的格子
禁手提示：当玩家选中滑块时，底部数字条会自动置灰（forbidden 样式）那些会导致冲突的数字

AI调度系统：
支持“人类 vs AI”、“AI vs AI”以及随时切换
内置延迟模拟思考过程，增强视觉反馈

多语言解耦：
使用 `msgObj` 存储状态，确保切换语言时当前提示信息同步翻译，无需手动刷新状态

4. 关键算法逻辑说明

胜负判定 (`getWinningLine`)

采用了八方向搜索算法。每当新棋子落下，从该点出发探测水平、垂直、两条对角线。如果该方向连子数 ，返回所有中招格子的索引数组用于高亮动画

布局自适应

PC 端：通过 `maxheight: 55vh` 确保棋盘在矮屏幕显示器上不会将标题挤出视野
移动端：棋盘宽度自适应，禁用了滚动条（`overflow: hidden`），提供全屏沉浸感

5. 后续开发规划

AI性能飞跃

方案 A：贪心算法（简单 / 初级）。AI只看当前这一步。逻辑：遍历所有合法位置，计算每个位置产生的乘积。优先级：如果一步能成胜利所需的连接(WIN_COUNT)，直接下。如果一步能堵住玩家的获胜连接，必须堵。否则，随机选一个

方案 B：启发式评估 + Minimax 算法（中级）。AI 会模拟“我走一步，你走一步”的过程。评分函数：给棋盘状态打分。例如，自己连成 2 个：+10 分。自己连成 3 个：+100 分。对方连成 3 个：-500 分。占据中心区域：+5 分。搜索深度：由于分支因子极小，搜索 4-6 层（即预测双方各走 3 步）即可

方案 C：蒙特卡洛树搜索（MCTS）（高级），类似 AlphaGo 的简化版。AI 通过成千上万次的随机自我对弈来判断哪一个动作的胜率最高。优点：不需要复杂的评分函数，能发现人类难以察觉的阴招。缺点：在 JavaScript 中实现较复杂，性能开销比 Minimax 大

游戏功能

本地战绩记录：使用 `localStorage` 记录玩家与不同难度 AI 的胜负比。记录落子顺序，实现回放、悔棋功能
另外增加一些统计功能方便后期研究，比如研究先手赢的概率
在页面上给玩家调整某些常量的可能，比如调整WIN_COUNT
再看看目前的代码还有哪些地方可以优化的，比如提取一些工具函数

联网对战

玩家可以联网对战